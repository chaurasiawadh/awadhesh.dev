<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>3D Hand-Tracked Particle System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #video-element {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 2;
            border: 2px solid #333;
            transform: scaleX(-1);
            opacity: 0.7;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 2;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        p {
            font-size: 0.9rem;
            color: #aaa;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 10;
            font-size: 1.5rem;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <div id="loading" class="loading">Loading AI Models...</div>

    <video id="video-element" playsinline></video>

    <div id="canvas-container"></div>

    <div id="ui">
        <h1 id="shape-name">Current: Sphere</h1>
        <p>üñê Open Hand: Expand | üëå Pinch: Contract | ‚û° Right Edge: Next Shape</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // Note: MediaPipe is loaded globally via script tags usually, but we will use the global objects 
        // provided by the CDN scripts injected below to ensure compatibility.

        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.08;
        const LERP_SPEED = 0.08; // How fast particles move to target

        // --- State ---
        let currentShapeIndex = 0;
        let isSwitching = false; // Debounce for shape switching
        let handState = { x: 0.5, y: 0.5, pinch: 0, isPresent: false };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Particle System ---
        // We store two buffers: 'position' (current) and 'target' (where they want to go)
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize random positions
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 20;
            targets[i] = positions[i];
            colors[i] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Shader Material for better performance and visual pop
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        const shapes = [
            { name: "Sphere", gen: getSpherePoints },
            { name: "Heart", gen: getHeartPoints },
            { name: "Saturn", gen: getSaturnPoints },
            { name: "Flower", gen: getFlowerPoints },
            { name: "Torus Knot", gen: getTorusKnotPoints },
            { name: "Fireworks", gen: getFireworksPoints }
        ];

        function getSpherePoints(i) {
            const r = 3;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function getHeartPoints(i) {
            // Parametric Heart equations
            const r = 0.25; // Scale
            const t = Math.random() * Math.PI * 2;
            const yVar = Math.random() * 2 - 1; // Volume thickness

            // X = 16sin^3(t)
            let x = 16 * Math.pow(Math.sin(t), 3);
            // Y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

            return {
                x: x * r,
                y: y * r,
                z: (Math.random() - 0.5) * 2 // Give it some depth
            };
        }

        function getSaturnPoints(i) {
            const ratio = 0.6; // Split particles between planet and ring
            if (Math.random() < ratio) {
                // Planet
                const r = 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            } else {
                // Ring
                const angle = Math.random() * Math.PI * 2;
                const r = 3.5 + Math.random() * 2; // Radius 3.5 to 5.5
                return {
                    x: r * Math.cos(angle),
                    y: (Math.random() - 0.5) * 0.2, // Thin disk
                    z: r * Math.sin(angle)
                };
            }
        }

        function getFlowerPoints(i) {
            const rBase = 3;
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            // Rose curve logic applied to sphere
            const k = 4; // Petals
            const r = rBase * Math.cos(k * u) + 1;

            return {
                x: r * Math.sin(v) * Math.cos(u),
                y: r * Math.sin(v) * Math.sin(u),
                z: r * Math.cos(v) * 0.5
            };
        }

        function getTorusKnotPoints(i) {
            const t = Math.random() * Math.PI * 2 * 3; // 3 loops
            const p = 2, q = 3;
            const scale = 1.5;
            const tubular = (Math.random() - 0.5) * 0.5;

            const r = 2 + Math.cos(q * t);
            return {
                x: scale * (r * Math.cos(p * t)) + tubular,
                y: scale * (r * Math.sin(p * t)) + tubular,
                z: scale * Math.sin(q * t)
            };
        }

        function getFireworksPoints(i) {
            // Explosion vectors
            const r = Math.random() * 6;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // --- Core Functions ---

        function updateShape(shapeIndex) {
            const genFunc = shapes[shapeIndex].gen;
            document.getElementById('shape-name').innerText = `Current: ${shapes[shapeIndex].name}`;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = genFunc(i);
                targets[i * 3] = pos.x;
                targets[i * 3 + 1] = pos.y;
                targets[i * 3 + 2] = pos.z;
            }
        }

        function nextShape() {
            if (isSwitching) return;
            isSwitching = true;
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            updateShape(currentShapeIndex);

            // Cooldown to prevent rapid switching
            setTimeout(() => isSwitching = false, 1500);
        }

        // Initialize first shape
        updateShape(0);

        // --- MediaPipe Integration ---

        // We need to load the MediaPipe scripts via JS since they aren't fully ES module friendly in all CDNs
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.body.appendChild(s);
            });
        }

        async function initMediaPipe() {
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");

            const videoElement = document.getElementById('video-element');

            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 320,
                height: 240
            });

            cameraUtils.start();

            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => document.getElementById('loading').remove(), 500);
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                handState.isPresent = true;

                // 1. Calculate Hand Center (using Index Finger MCP and Wrist)
                // Coordinates are normalized [0, 1]
                const x = landmarks[9].x; // Index base
                const y = landmarks[9].y;

                // Smoothing
                handState.x += (x - handState.x) * 0.1;
                handState.y += (y - handState.y) * 0.1;

                // 2. Calculate Pinch (Distance between Thumb Tip [4] and Index Tip [8])
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                // Map distance to pinch factor (0 = pinched, 1 = open)
                // Typicall pinch is < 0.05, open is > 0.15
                let pinchRaw = (distance - 0.03) * 5;
                handState.pinch = Math.max(0, Math.min(1, pinchRaw));

                // 3. Gesture Detection for Shape Switch
                // If hand is at the far right edge of the screen (Video is mirrored, so x < 0.1)
                // Note: landmarks.x is normalized. 0 is left, 1 is right.
                // Since we flipped the video with CSS, visual right is actually coordinate left (0.1)
                if (landmarks[0].x < 0.15) {
                    nextShape();
                }

            } else {
                handState.isPresent = false;
                // Slowly reset pinch to neutral if hand lost
                handState.pinch += (1 - handState.pinch) * 0.05;
            }
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const positionsArray = geometry.attributes.position.array;
            const colorsArray = geometry.attributes.color.array;

            // Interaction Modifiers
            // 1. Expansion based on Pinch
            // If pinch is 0 (tight), expansion is low. If pinch is 1 (open), expansion is high.
            // Let's invert: Open hand = spread out. Fist = collapsed.
            const expansion = 0.5 + (handState.pinch * 1.5); // Range 0.5 to 2.0

            // 2. Rotation based on Hand X/Y
            // We rotate the whole particle system container
            const targetRotX = (handState.y - 0.5) * 2;
            const targetRotY = (handState.x - 0.5) * 2;

            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.05;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.05;

            // Auto rotation if no hand
            if (!handState.isPresent) {
                particles.rotation.y += 0.005;
            }

            // Update Particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // Move current pos towards target pos
                let tx = targets[ix] * expansion;
                let ty = targets[iy] * expansion;
                let tz = targets[iz] * expansion;

                // Add some noise/wave movement
                tx += Math.sin(time + positionsArray[iy]) * 0.05;
                ty += Math.cos(time + positionsArray[ix]) * 0.05;

                // Lerp position
                positionsArray[ix] += (tx - positionsArray[ix]) * LERP_SPEED;
                positionsArray[iy] += (ty - positionsArray[iy]) * LERP_SPEED;
                positionsArray[iz] += (tz - positionsArray[iz]) * LERP_SPEED;

                // Dynamic Color
                // Hue based on X position + time
                const h = (positionsArray[ix] * 0.05 + time * 0.1) % 1;
                // Saturation based on Pinch (Hand Open = Colorful, Fist = White/Hot)
                const s = 0.5 + (handState.pinch * 0.5);
                const color = new THREE.Color().setHSL(h, s, 0.6);

                colorsArray[ix] = color.r;
                colorsArray[iy] = color.g;
                colorsArray[iz] = color.b;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        initMediaPipe();
        animate();

    </script>
</body>

</html>